[
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "line_aa",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "ellipse_perimeter",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "line_aa",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "ellipse_perimeter",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "line",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "line_aa",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "ellipse_perimeter",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "line",
        "importPath": "skimage.draw",
        "description": "skimage.draw",
        "isExtraImport": true,
        "detail": "skimage.draw",
        "documentation": {}
    },
    {
        "label": "atan2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atan2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "atan2",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "resize",
        "importPath": "skimage.transform",
        "description": "skimage.transform",
        "isExtraImport": true,
        "detail": "skimage.transform",
        "documentation": {}
    },
    {
        "label": "resize",
        "importPath": "skimage.transform",
        "description": "skimage.transform",
        "isExtraImport": true,
        "detail": "skimage.transform",
        "documentation": {}
    },
    {
        "label": "resize",
        "importPath": "skimage.transform",
        "description": "skimage.transform",
        "isExtraImport": true,
        "detail": "skimage.transform",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "filter2",
        "importPath": "scripts.filter_2",
        "description": "scripts.filter_2",
        "isExtraImport": true,
        "detail": "scripts.filter_2",
        "documentation": {}
    },
    {
        "label": "filter2",
        "importPath": "scripts.filter_2",
        "description": "scripts.filter_2",
        "isExtraImport": true,
        "detail": "scripts.filter_2",
        "documentation": {}
    },
    {
        "label": "filter4",
        "importPath": "scripts.filter_4",
        "description": "scripts.filter_4",
        "isExtraImport": true,
        "detail": "scripts.filter_4",
        "documentation": {}
    },
    {
        "label": "filter4",
        "importPath": "scripts.filter_4",
        "description": "scripts.filter_4",
        "isExtraImport": true,
        "detail": "scripts.filter_4",
        "documentation": {}
    },
    {
        "label": "filter5",
        "importPath": "scripts.filter_5",
        "description": "scripts.filter_5",
        "isExtraImport": true,
        "detail": "scripts.filter_5",
        "documentation": {}
    },
    {
        "label": "filter5",
        "importPath": "scripts.filter_5",
        "description": "scripts.filter_5",
        "isExtraImport": true,
        "detail": "scripts.filter_5",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "dirname",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "exists",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "makedirs",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "scandir",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "remove",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "flash",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "abort",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "url_for",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "cross_origin",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "qrcode",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "qrcode",
        "description": "qrcode",
        "detail": "qrcode",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "scripts",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scripts",
        "description": "scripts",
        "detail": "scripts",
        "documentation": {}
    },
    {
        "label": "filter2",
        "kind": 2,
        "importPath": "app.scripts.filter_2",
        "description": "app.scripts.filter_2",
        "peekOfCode": "def filter2(image, intensity=0.6, saturation=0.7, light_adapt=0.7):\n    img = np.float32(image) / 255.0\n    mapped_image = np.clip(img * (1.0 + (img * intensity) / (img + 0.01)), 0, 1)\n    mapped_image = np.uint8(mapped_image * 255)\n    hsv_mapped_image = cv2.cvtColor(mapped_image, cv2.COLOR_BGR2HSV)\n    hsv_mapped_image[..., 1] = np.clip(hsv_mapped_image[..., 1] * saturation, 0, 255)\n    final_image = cv2.cvtColor(hsv_mapped_image, cv2.COLOR_HSV2BGR)\n    final_image = np.clip(final_image * light_adapt, 0, 255).astype(np.uint8)\n    return final_image",
        "detail": "app.scripts.filter_2",
        "documentation": {}
    },
    {
        "label": "filter4",
        "kind": 2,
        "importPath": "app.scripts.filter_4",
        "description": "app.scripts.filter_4",
        "peekOfCode": "def filter4(image):\n    lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)\n    l, a, b = cv2.split(lab)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n    cl = clahe.apply(l)\n    enhanced_lab = cv2.merge((cl, a, b))\n    enhanced_bgr = cv2.cvtColor(enhanced_lab, cv2.COLOR_LAB2BGR)\n    return enhanced_bgr",
        "detail": "app.scripts.filter_4",
        "documentation": {}
    },
    {
        "label": "filter5",
        "kind": 2,
        "importPath": "app.scripts.filter_5",
        "description": "app.scripts.filter_5",
        "peekOfCode": "def filter5(image):\n    gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)\n    equalized = cv2.equalizeHist(gray)\n    equalized_color = cv2.cvtColor(equalized, cv2.COLOR_GRAY2BGR)\n    return equalized_color",
        "detail": "app.scripts.filter_5",
        "documentation": {}
    },
    {
        "label": "rgb2gray",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2\n    if short_edge == 0:\n        return image[:, long_edge_center - short_edge_half:\n                        long_edge_center + short_edge_half]\n    if short_edge == 1:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "largest_square",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2\n    if short_edge == 0:\n        return image[:, long_edge_center - short_edge_half:\n                        long_edge_center + short_edge_half]\n    if short_edge == 1:\n        return image[long_edge_center - short_edge_half:\n                     long_edge_center + short_edge_half, :]",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "create_circle_nail_positions",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1\n    theta = np.linspace(0, 2 * np.pi, nail_count, endpoint=False)\n    rr = centre[0] + np.round(radius * r1_multip * np.cos(theta)).astype(int)\n    cc = centre[1] + np.round(radius * r2_multip * np.sin(theta)).astype(int)\n    nails = np.column_stack((rr, cc))\n    # nails = nails.tolist()",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "init_canvas",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def init_canvas(shape, black=False):\n    if black:\n        return np.zeros(shape)\n    else:\n        return np.ones(shape)\ndef get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    line = picture[rr, cc] + str_strength * val\n    line = np.clip(line, a_min=0, a_max=1)\n    return line, rr, cc",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "get_aa_line",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    line = picture[rr, cc] + str_strength * val\n    line = np.clip(line, a_min=0, a_max=1)\n    return line, rr, cc\ndef find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength):\n    best_cumulative_improvement = -99999\n    best_nail_position = None\n    best_nail_idx = None\n    if RANDOM_NAILS is not None:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "find_best_nail_position",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength):\n    best_cumulative_improvement = -99999\n    best_nail_position = None\n    best_nail_idx = None\n    if RANDOM_NAILS is not None:\n        nail_ids = np.random.choice(range(len(nails)), size=RANDOM_NAILS, replace=False)\n        nails_and_ids = list(zip(nail_ids, nails[nail_ids]))\n    else:\n        nails_and_ids = enumerate(nails)\n    for nail_idx, nail_position in nails_and_ids:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "create_art",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def create_art(nails, orig_pic, str_pic, str_strength, i_limit=None):\n    start = time()\n    iter_times = []\n    current_position = nails[0]\n    pull_order = [0]\n    i = 0\n    fails = 0\n    while True:\n        start_iter = time()\n        i += 1",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "scale_nails",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def scale_nails(x_ratio, y_ratio, nails):\n    return [(int(y_ratio * nail[0]), int(x_ratio * nail[1])) for nail in nails]\ndef pull_order_to_array_bw(order, canvas, nails, strength):\n    # Draw a black and white pull order on the defined resolution\n    for pull_start, pull_end in zip(order, order[1:]):  # pairwise iteration\n        rr, cc, val = line_aa(nails[pull_start][0], nails[pull_start][1],\n                              nails[pull_end][0], nails[pull_end][1])\n        canvas[rr, cc] += val * strength\n    return np.clip(canvas, a_min=0, a_max=1)\ndef generate(path, filename):",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "pull_order_to_array_bw",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def pull_order_to_array_bw(order, canvas, nails, strength):\n    # Draw a black and white pull order on the defined resolution\n    for pull_start, pull_end in zip(order, order[1:]):  # pairwise iteration\n        rr, cc, val = line_aa(nails[pull_start][0], nails[pull_start][1],\n                              nails[pull_end][0], nails[pull_end][1])\n        canvas[rr, cc] += val * strength\n    return np.clip(canvas, a_min=0, a_max=1)\ndef generate(path, filename):\n    LONG_SIDE = 300\n    input_file = path + filename",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "def generate(path, filename):\n    LONG_SIDE = 300\n    input_file = path + filename\n    img = cv2.imread(input_file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    if np.any(img > 100):\n        img = img / 255\n    # cv2.imshow('frame', img); cv2.waitKey(0)\n    if RADIUS1_MULTIPLIER == 1 and RADIUS2_MULTIPLIER == 1:\n        img = largest_square(img)",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "OUTPUT_FILE",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "OUTPUT_FILE = \"output.png\"\nSIDE_LEN = 300\nEXPORT_STRENGTH = 0.035\nPULL_AMOUNT = 4000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "SIDE_LEN",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "SIDE_LEN = 300\nEXPORT_STRENGTH = 0.035\nPULL_AMOUNT = 4000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "EXPORT_STRENGTH",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "EXPORT_STRENGTH = 0.035\nPULL_AMOUNT = 4000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "PULL_AMOUNT",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "PULL_AMOUNT = 4000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "RANDOM_NAILS",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "RANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "RADIUS1_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "RADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2\n    if short_edge == 0:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "RADIUS2_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "RADIUS2_MULTIPLIER = 1\nNAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2\n    if short_edge == 0:\n        return image[:, long_edge_center - short_edge_half:",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "NAIL_STEP",
        "kind": 5,
        "importPath": "app.scripts.new_generator",
        "description": "app.scripts.new_generator",
        "peekOfCode": "NAIL_STEP = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    short_edge = np.argmin(image.shape[:2])  # 0 = vertical <= horizontal; 1 = otherwise\n    short_edge_half = image.shape[short_edge] // 2\n    long_edge_center = image.shape[1 - short_edge] // 2\n    if short_edge == 0:\n        return image[:, long_edge_center - short_edge_half:\n                        long_edge_center + short_edge_half]",
        "detail": "app.scripts.new_generator",
        "documentation": {}
    },
    {
        "label": "rgb2gray",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "largest_square",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1\n    theta = np.linspace(0, 2 * np.pi, nail_count, endpoint=False)\n    rr = centre[0] + np.round(radius * r1_multip * np.cos(theta)).astype(int)",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "create_circle_nail_positions",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1\n    theta = np.linspace(0, 2 * np.pi, nail_count, endpoint=False)\n    rr = centre[0] + np.round(radius * r1_multip * np.cos(theta)).astype(int)\n    cc = centre[1] + np.round(radius * r2_multip * np.sin(theta)).astype(int)\n    nails = np.column_stack((rr, cc))\n    # nails = nails.tolist()",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "init_canvas",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def init_canvas(shape, black=False):\n    if black:\n        return np.zeros(shape)\n    else:\n        return np.ones(shape)\ndef get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    lin = picture[rr, cc] + str_strength*val\n    lin = np.clip(lin, a_min=0, a_max=1)\n    return lin, rr, cc",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "get_aa_line",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    lin = picture[rr, cc] + str_strength*val\n    lin = np.clip(lin, a_min=0, a_max=1)\n    return lin, rr, cc\n# def find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength):\n#     overlayed_lines = []\n#     rr_list = []\n#     cc_list = []\n#     if RANDOM_NAILS is not None:",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "find_best_nail_position",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength):\n    overlayed_lines = []\n    rr_list = []\n    cc_list = []\n    cumulative_improvements = []\n    if RANDOM_NAILS is not None:\n        nail_ids = np.random.choice(len(nails), size=RANDOM_NAILS, replace=False)\n        nails_and_ids = nails[nail_ids]\n    else:\n        nails_and_ids = nails",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "create_art",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def create_art(nails, orig_pic, str_pic, str_strength, i_limit=None):\n    start = time()\n    iter_times = []\n    current_position = nails[0]\n    pull_order = [0]\n    i = 0\n    fails = 0\n    while True:\n        i += 1\n        if i % 500 == 0:",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "scale_nails",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def scale_nails(x_ratio, y_ratio, nails):\n    return [(int(y_ratio * nail[0]), int(x_ratio * nail[1])) for nail in nails]\ndef pull_order_to_array_bw(order, canvas, nails, strength):\n    # Draw a black and white pull order on the defined resolution\n    for pull_start, pull_end in zip(order, order[1:]):  # pairwise iteration\n        rr, cc = line(nails[pull_start][0], nails[pull_start][1],\n                              nails[pull_end][0], nails[pull_end][1])\n        canvas[rr, cc] += strength\n    return np.clip(canvas, a_min=0, a_max=1)\ndef generate(img, output_file):",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "pull_order_to_array_bw",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def pull_order_to_array_bw(order, canvas, nails, strength):\n    # Draw a black and white pull order on the defined resolution\n    for pull_start, pull_end in zip(order, order[1:]):  # pairwise iteration\n        rr, cc = line(nails[pull_start][0], nails[pull_start][1],\n                              nails[pull_end][0], nails[pull_end][1])\n        canvas[rr, cc] += strength\n    return np.clip(canvas, a_min=0, a_max=1)\ndef generate(img, output_file):\n    LONG_SIDE = 250\n    if np.any(img > 100):",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def generate(img, output_file):\n    LONG_SIDE = 250\n    if np.any(img > 100):\n        img = img / 255\n    # cv2.imshow('frame', img); cv2.waitKey(0)\n    if RADIUS1_MULTIPLIER == 1 and RADIUS2_MULTIPLIER == 1:\n        img = largest_square(img)\n        img = cv2.resize(img, (LONG_SIDE, LONG_SIDE))\n    shape = (len(img), len(img[0]))\n    nails = create_circle_nail_positions(shape, NAILS_SIZE, RADIUS1_MULTIPLIER, RADIUS2_MULTIPLIER)",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "generate_all",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def generate_all(path, filename):\n    input_file = path + filename\n    img = cv2.imread(input_file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img1 = generate(img, path + 'result1')\n    img2 = generate(filter2(img), path + 'result2')\n    img3 = generate(filter4(img), path + 'result3')\n    img4 = generate(filter5(img), path + 'result4')\n    return True\ndef generate_all_with_processing(path, filename):",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "generate_all_with_processing",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "def generate_all_with_processing(path, filename):\n    input_file = path + filename\n    img = cv2.imread(input_file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img_params = [\n        (img, path + 'result1'),\n        (filter2(img), path + 'result2'),\n        (filter4(img), path + 'result3'),\n        (filter5(img), path + 'result4')\n    ]",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "OUTPUT_FILE",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "OUTPUT_FILE = \"output.png\"\nSIDE_LEN = 500\nEXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "SIDE_LEN",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "SIDE_LEN = 500\nEXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "EXPORT_STRENGTH",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "EXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "PULL_AMOUNT",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "PULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "RANDOM_NAILS",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "RANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "RADIUS1_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "RADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "RADIUS2_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "RADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "NAILS_SIZE",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised",
        "description": "app.scripts.new_generator_optimised",
        "peekOfCode": "NAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    return image[:size, :size]\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)",
        "detail": "app.scripts.new_generator_optimised",
        "documentation": {}
    },
    {
        "label": "rgb2gray",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "largest_square",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1\n    theta = np.linspace(0, 2 * np.pi, nail_count, endpoint=False)",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "create_circle_nail_positions",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]\n    centre = (height // 2, width // 2)\n    radius = min(height, width) // 2 - 1\n    theta = np.linspace(0, 2 * np.pi, nail_count, endpoint=False)\n    rr = centre[0] + np.round(radius * r1_multip * np.cos(theta)).astype(int)\n    cc = centre[1] + np.round(radius * r2_multip * np.sin(theta)).astype(int)\n    nails = np.column_stack((rr, cc))\n    # nails = nails.tolist()",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "init_canvas",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def init_canvas(shape, black=False):\n    if black:\n        return np.zeros(shape)\n    else:\n        return np.ones(shape)\ndef get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    lin = picture[rr, cc] + str_strength*val\n    lin = np.clip(lin, a_min=0, a_max=1)\n    return lin, rr, cc",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "get_aa_line",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def get_aa_line(from_pos, to_pos, str_strength, picture):\n    rr, cc, val = line_aa(from_pos[0], from_pos[1], to_pos[0], to_pos[1])\n    lin = picture[rr, cc] + str_strength*val\n    lin = np.clip(lin, a_min=0, a_max=1)\n    return lin, rr, cc\n# def find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength):\n#     overlayed_lines = []\n#     rr_list = []\n#     cc_list = []\n#     if RANDOM_NAILS is not None:",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "find_best_nail_position",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def find_best_nail_position(current_position, nails, str_pic, orig_pic, str_strength, RANDOM_NAILS=None):\n    overlayed_lines = []\n    cumulative_improvements = []\n    if RANDOM_NAILS is not None:\n        nail_ids = np.random.choice(len(nails), size=RANDOM_NAILS, replace=False)\n        nails_and_ids = nails[nail_ids]\n    else:\n        nails_and_ids = nails\n    overlayed_lines, rr_list, cc_list = get_aa_lines(current_position, nails_and_ids, str_strength, str_pic)\n    before_overlayed_line_diff = np.abs(str_pic[rr_list, cc_list] - orig_pic[rr_list, cc_list]) ** 2",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "get_aa_lines",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def get_aa_lines(current_position, nails_and_ids, str_strength, str_pic):\n    overlayed_lines = []\n    rr_list = []\n    cc_list = []\n    for nail_position in nails_and_ids:\n        overlayed_line, rr, cc = get_aa_line(current_position, nail_position, str_strength, str_pic)\n        overlayed_lines.append(overlayed_line)\n        rr_list.append(rr)\n        cc_list.append(cc)\n    return overlayed_lines, np.concatenate(rr_list), np.concatenate(cc_list)",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "create_art",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def create_art(nails, orig_pic, str_pic, str_strength, i_limit=None):\n    start = time()\n    iter_times = []\n    current_position = nails[0]\n    pull_order = [0]\n    i = 0\n    fails = 0\n    while True:\n        i += 1\n        if i % 500 == 0:",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "scale_nails",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def scale_nails(x_ratio, y_ratio, nails):\n    scaled_nails = np.array(nails)  # Преобразуем список nails в массив NumPy\n    scaled_nails[:, 0] = np.round(scaled_nails[:, 0] * y_ratio).astype(int)\n    scaled_nails[:, 1] = np.round(scaled_nails[:, 1] * x_ratio).astype(int)\n    return scaled_nails.tolist()\n# def pull_order_to_array_bw(order, canvas, nails, strength):\n#     for pull_start, pull_end in zip(order, order[1:]):  # pairwise iteration\n#         rr, cc = line(nails[pull_start][0], nails[pull_start][1],\n#                               nails[pull_end][0], nails[pull_end][1])\n#         canvas[rr, cc] += strength",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "pull_order_to_array_bw",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def pull_order_to_array_bw(order, canvas, nails, strength):\n    pull_start_points = np.array([nails[pull_start] for pull_start in order])\n    pull_end_points = np.array([nails[pull_end] for pull_end in order[1:]])\n    rr, cc = line(pull_start_points[:, 0].astype(int), pull_start_points[:, 1].astype(int),\n                  pull_end_points[:, 0].astype(int), pull_end_points[:, 1].astype(int))\n    canvas[rr, cc] += strength\n    return np.clip(canvas, a_min=0, a_max=1)\ndef generate(img, output_file):\n    LONG_SIDE = 250\n    if np.any(img > 100):",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "generate",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def generate(img, output_file):\n    LONG_SIDE = 250\n    if np.any(img > 100):\n        img = img / 255\n    # cv2.imshow('frame', img); cv2.waitKey(0)\n    if RADIUS1_MULTIPLIER == 1 and RADIUS2_MULTIPLIER == 1:\n        img = largest_square(img)\n        img = cv2.resize(img, (LONG_SIDE, LONG_SIDE))\n    shape = (len(img), len(img[0]))\n    nails = create_circle_nail_positions(shape, NAILS_SIZE, RADIUS1_MULTIPLIER, RADIUS2_MULTIPLIER)",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "generate_all",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def generate_all(path, filename):\n    input_file = path + filename\n    img = cv2.imread(input_file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img1 = generate(img, path + 'result1')\n    img2 = generate(filter2(img), path + 'result2')\n    img3 = generate(filter4(img), path + 'result3')\n    img4 = generate(filter5(img), path + 'result4')\n    return True\ndef generate_all_with_processing(path, filename):",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "generate_all_with_processing",
        "kind": 2,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "def generate_all_with_processing(path, filename):\n    input_file = path + filename\n    img = cv2.imread(input_file)\n    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n    img_params = [\n        (img, path + 'result1'),\n        (filter2(img), path + 'result2'),\n        (filter4(img), path + 'result3'),\n        (filter5(img), path + 'result4')\n    ]",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "OUTPUT_FILE",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "OUTPUT_FILE = \"output.png\"\nSIDE_LEN = 500\nEXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "SIDE_LEN",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "SIDE_LEN = 500\nEXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "EXPORT_STRENGTH",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "EXPORT_STRENGTH = 0.07\nPULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "PULL_AMOUNT",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "PULL_AMOUNT = 5000\nRANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "RANDOM_NAILS",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "RANDOM_NAILS = None\nRADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "RADIUS1_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "RADIUS1_MULTIPLIER = 1\nRADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "RADIUS2_MULTIPLIER",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "RADIUS2_MULTIPLIER = 1\nNAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "NAILS_SIZE",
        "kind": 5,
        "importPath": "app.scripts.new_generator_optimised_new",
        "description": "app.scripts.new_generator_optimised_new",
        "peekOfCode": "NAILS_SIZE = 240\ndef rgb2gray(rgb):\n    return np.dot(rgb[..., :3], [0.2989, 0.5870, 0.1140])\ndef largest_square(image: np.ndarray) -> np.ndarray:\n    size = min(image.shape[:2])\n    image[:size, :size] = image[:size, :size]\n    return image\ndef create_circle_nail_positions(shape, nail_count=240, r1_multip=1, r2_multip=1):\n    height = shape[0]\n    width = shape[1]",
        "detail": "app.scripts.new_generator_optimised_new",
        "documentation": {}
    },
    {
        "label": "allowed_file",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):\n        makedirs(path)\n@app.route('/api/upload1', methods=['POST'])\n@cross_origin()\ndef create_task1():",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "create_folder",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):\n        makedirs(path)\n@app.route('/api/upload1', methods=['POST'])\n@cross_origin()\ndef create_task1():\n    folder = request.form['code']\n    create_folder(UPLOAD_FOLDER, folder)\n    direct = app.config['UPLOAD_FOLDER']+\"/\"+folder",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "create_task1",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def create_task1():\n    folder = request.form['code']\n    create_folder(UPLOAD_FOLDER, folder)\n    direct = app.config['UPLOAD_FOLDER']+\"/\"+folder\n    for file in scandir(direct):\n        remove(file.path)    \n    if 'file' in request.form:\n        encoded_image = request.form['file']\n        decoded_image = base64.b64decode(encoded_image.split(',')[1])\n        image = Image.open(BytesIO(decoded_image))",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "create_qr",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def create_qr():\n    hash = request.args.get('hash')\n    qr = qrcode.QRCode(version=1, box_size=10, border=2)\n    qr.add_data('https://mypoint.mydev.kz/assembly/'+hash)\n    qr.make(fit=True)\n    img = qr.make_image(fill=\"black\", back_color=\"#FAFAFA\")\n    # Сохранение QR-кода в файл\n    image_path = \"qrcode.jpg\"  # Путь к файлу изображения QR-кода\n    img.save(image_path)\n    return send_file(image_path, mimetype=\"image/png\")",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "send_static",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def send_static(path, name):\n    return send_from_directory(app.config['UPLOAD_FOLDER'] + \"/\" + path, name)\n@app.route('/')\n@cross_origin()\ndef index():\n    return \"MyPointArt Generator API! \"\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3021, debug=True)",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "def index():\n    return \"MyPointArt Generator API! \"\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3021, debug=True)",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "UPLOAD_FOLDER",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "UPLOAD_FOLDER = 'upload'\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\napp = Flask(__name__, static_folder='/upload')\napp.config[\"DEBUG\"] = True\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "ALLOWED_EXTENSIONS",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\napp = Flask(__name__, static_folder='/upload')\napp.config[\"DEBUG\"] = True\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "app = Flask(__name__, static_folder='/upload')\napp.config[\"DEBUG\"] = True\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "app.config[\"DEBUG\"]",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "app.config[\"DEBUG\"] = True\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "app.config['UPLOAD_FOLDER']",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ncors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):\n        makedirs(path)",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "cors",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "cors = CORS(app)\napp.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):\n        makedirs(path)\n@app.route('/api/upload1', methods=['POST'])",
        "detail": "app.app",
        "documentation": {}
    },
    {
        "label": "app.config['CORS_HEADERS']",
        "kind": 5,
        "importPath": "app.app",
        "description": "app.app",
        "peekOfCode": "app.config['CORS_HEADERS'] = 'Content-Type'\ndef allowed_file(filename):\n    return '.' in filename and \\\n        filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef create_folder(workspace, folder):\n    path = join(workspace, folder)\n    if not exists(path):\n        makedirs(path)\n@app.route('/api/upload1', methods=['POST'])\n@cross_origin()",
        "detail": "app.app",
        "documentation": {}
    }
]